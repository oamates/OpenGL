#ifndef _rand_included_89715693756419437645132765418927560827356178651892735698
#define _rand_included_89715693756419437645132765418927560827356178651892735698

#include <chrono>

namespace random {

struct generator_t
{
    uint64_t seq_x;
    uint64_t seq_y;

    generator_t()
        { seed(); }

    void seed()
    {
        std::chrono::high_resolution_clock::time_point now = std::chrono::high_resolution_clock::now();
        uint64_t timer_seed = std::chrono::duration<uint64_t, std::chrono::nanoseconds::period>(now.time_since_epoch()).count();
        seed((uint32_t) timer_seed, (uint32_t) (timer_seed >> 32));
    }

    void seed(uint32_t x, uint32_t y)
    {
        static const uint64_t C1 = 0xFF51AFD7ED558CCDULL;
        static const uint64_t C2 = 0xC4CEB9FE1A85EC53ULL;
        
        x += y;
        y += x;
        
        uint64_t seed_x = 0x9368E53C2F6AF274ULL ^ x;
        uint64_t seed_y = 0x586DCD208F7CD3FDULL ^ y;
        
        seed_x *= C1;
        seed_x ^= seed_x >> 33;
        seed_x *= C2;
        seed_x ^= seed_x >> 33;
        
        seed_y *= C1;
        seed_y ^= seed_y >> 33;
        seed_y *= C2;
        seed_y ^= seed_y >> 33;
        
        seq_x = seed_x;
        seq_y = seed_y;
        
        seq_x = (uint64_t)0xFFFD21A7 * (uint32_t)seq_x + (uint32_t)(seq_x >> 32);
        seq_y = (uint64_t)0xFFFD1361 * (uint32_t)seq_y + (uint32_t)(seq_y >> 32);
    }

    //===================================================================================================================================================================================================================
    // main function :: unsigned 32-bit integer uniformly over full 32-bit range
    //===================================================================================================================================================================================================================
    uint32_t uniform_rand1ui()
    {
        seq_x = (uint64_t)0xFFFD21A7 * (uint32_t)seq_x + (uint32_t)(seq_x >> 32);
        seq_y = (uint64_t)0xFFFD1361 * (uint32_t)seq_y + (uint32_t)(seq_y >> 32);
        return (((uint32_t) seq_x << 7) | ((uint32_t) seq_x >> 25)) + (uint32_t) seq_y;
    }

    int32_t uniform_rand1i()
        { return (int32_t) uniform_rand1ui(); }

    //===================================================================================================================================================================================================================
    // integer uniformly distributed over closed interval [0 .. imax - 1]
    //===================================================================================================================================================================================================================
    int32_t uniform_rand1i(int32_t imax)
        { return uniform_rand1i() % imax; }

    //===================================================================================================================================================================================================================
    // integer uniformly distributed over closed interval [imin..imax-1]
    //===================================================================================================================================================================================================================
    int32_t uniform_rand1i(int32_t imin, int32_t imax)
        { return imin + uniform_rand1i(imax - imin); }

    //===================================================================================================================================================================================================================
    // double uniformly distributed on closed unit interval [0..1]
    //===================================================================================================================================================================================================================
    double uniform_rand1d()
        { return uniform_rand1ui() * (1.0 / 4294967295.0); }

    //===================================================================================================================================================================================================================
    // double uniformly distributed on the givrn open interval [dmin..dmax]
    //===================================================================================================================================================================================================================
    double uniform_rand1d(double dmin, double dmax)
        { return dmin + (dmax - dmin) * uniform_rand1d(); }

    //===================================================================================================================================================================================================================
    // 2d point uniformly distributed inside the unit circle
    //===================================================================================================================================================================================================================
    double ball_rand2d(glm::dvec2& v)
    {
        double r;
        do
        {
            v.x = uniform_rand1d(-1.0, 1.0);
            v.y = uniform_rand1d(-1.0, 1.0);
            r = v.x * v.x + v.y * v.y;
        }
        while (r >= 1.0);
        return r;
    }

    //===================================================================================================================================================================================================================
    // point normally distributed on two-dimensional plane
    //===================================================================================================================================================================================================================
    glm::dvec2 normal_rand2d()
    {
        glm::dvec2 v;
        double r = ball_rand2d(v);                           // Apply radial transform to get normal 2d distribution 
                                                                    // x, y components are normally distributed
        double f = sqrt(-2 * log(r) / r);
        return f * v;
    }

    //===================================================================================================================================================================================================================
    // 2d point uniformly distributed on the unit circle
    //===================================================================================================================================================================================================================
    glm::dvec2 circle_rand2d()
    {
        glm::dvec2 v;
        double inv_r = 1.0 / ball_rand2d(v);
        return inv_r * v; 
    }

    //===================================================================================================================================================================================================================
    // vector uniformly distributed on 4-dimensional sphere
    //===================================================================================================================================================================================================================
    glm::dvec4 unit_rand4d()
    {
        glm::dvec4 v;
        double r_xy = ball_rand2d(*((glm::dvec2*) &v.x));
        double r_uv = ball_rand2d(*((glm::dvec2*) &v.z));
        double f = glm::sqrt((1.0 - r_xy) / r_uv);
        v.z *= f;
        v.w *= f;
        return v;
    }
};

} // namespace random

#endif // _rand_included_89715693756419437645132765418927560827356178651892735698
