#ifndef __torus_included_019371234523712712947321224513980696703855102481925496
#define __torus_included_019371234523712712947321224513980696703855102481925496

#define GLEW_STATIC
#include <GL/glew.h>
#include <glm/glm.hpp>

#include "vertex.hpp"
#include "vao.hpp"

//=======================================================================================================================================================================================================================
// Toral function types for procedural generation of surfaces, homeomorphic to torus, all functions passed to this struct routine must be (1,1) - periodic
//=======================================================================================================================================================================================================================
typedef float (*toral_landscape_func) (const glm::vec2& uv, int level);

//=======================================================================================================================================================================================================================
// The main structure
//=======================================================================================================================================================================================================================
struct torus_t
{
    vao_t vao;

     torus_t() {};
    ~torus_t() {};

    //===================================================================================================================================================================================================================
    // Construct 2d surface topologically equivalent to torus given a full generating function as a single triangle strip
    // integers size_x and size_y must be coprime
    //===================================================================================================================================================================================================================
    template<typename vertex_t> void generate_vao_ss(typename maps<vertex_t>::toral_func func, unsigned int size_x, unsigned int size_y, adjacency_vao_t* adjacency_vao_ptr = 0);

    //===================================================================================================================================================================================================================
    // Construct 2d surface topologically equivalent to torus given a full generating function
    //===================================================================================================================================================================================================================
    template<typename vertex_t> void generate_vao(typename maps<vertex_t>::toral_func func, int size_x, int size_y, adjacency_vao_t* adjacency_vao_ptr = 0);

    //===================================================================================================================================================================================================================
    // Assuming that the vertex generating function is a costly to compute, the function below uses multiple threads to fill in the vertex and index buffer
    // Toral topology allows this as torus obviously splits into a union of triangular strips and calculations can be done independently
    //===================================================================================================================================================================================================================
    template<typename vertex_t, int threads = 8> void generate_vao_mt(typename maps<vertex_t>::toral_func func, int size_x, int size_y);

    //===================================================================================================================================================================================================================
    // Rendering functions
    //===================================================================================================================================================================================================================
    void render();
    void render(GLsizei count, const GLvoid* offset);
    void instanced_render(GLsizei primcount);


  private:
    //===================================================================================================================================================================================================================
    // Auxiliary structure for multithreaded buffer filling
    //===================================================================================================================================================================================================================
    template<typename vertex_t> struct compute_data
    {
        //===============================================================================================================================================================================================================
        // computation parameters : uv subdivision levels
        //===============================================================================================================================================================================================================
        int size_x, size_y;
        float delta_x, delta_y;
        int strips_per_thread, vertices_per_thread, indices_per_thread;

        //===============================================================================================================================================================================================================
        // dynamically allocated attribute and index buffers for the functions below to fill
        //===============================================================================================================================================================================================================
        vertex_t* vertices;
        GLuint* indices;
    };

    //===================================================================================================================================================================================================================
    // Auxiliary function that populates a chunk of vertex and index buffers based on its thread id
    //===================================================================================================================================================================================================================
    template<typename vertex_t> static void fill_vao_chunk(typename maps<vertex_t>::toral_func func, const compute_data<vertex_t>& data, int thread_id);
};


#endif // __torus_included_019371234523712712947321224513980696703855102481925496
