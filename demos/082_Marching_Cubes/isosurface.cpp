//=======================================================================================================================================================================================================================
// Marching cubes algorithm implementation
//=======================================================================================================================================================================================================================

#include <cstdlib>
#include <map>
#include <vector>

#include <glm/gtx/string_cast.hpp>
#include <glm/ext.hpp> 

#include "log.hpp"
#include "isosurface.hpp"
#include "vertex.hpp"

//========================================================================================================================================================================================================================
// cube_vertices represents vertex displacement from the base vertex of a unit cube
//========================================================================================================================================================================================================================
const glm::dvec3 cube_vertices[8] =
{
    glm::dvec3(0.0, 0.0, 0.0),
    glm::dvec3(1.0, 0.0, 0.0),
    glm::dvec3(0.0, 1.0, 0.0),
    glm::dvec3(1.0, 1.0, 0.0),
    glm::dvec3(0.0, 0.0, 1.0),
    glm::dvec3(1.0, 0.0, 1.0),
    glm::dvec3(0.0, 1.0, 1.0),
    glm::dvec3(1.0, 1.0, 1.0)
};

//========================================================================================================================================================================================================================
// cube_edges contains initial and terminal indices of all the 12 edges of a cube 
//========================================================================================================================================================================================================================
const GLbyte cube_edges[12][2] = {{0, 1}, {2, 3}, {4, 5}, {6, 7}, 
                                  {0, 2}, {1, 3}, {4, 6}, {5, 7}, 
                                  {0, 4}, {1, 5}, {2, 6}, {3, 7}};

const unsigned int SHIFT = 10;

const GLuint edge_local_hash[12] = 
{
    (1 << 0) + (0 << SHIFT) + (0 << (SHIFT + SHIFT)),
    (1 << 0) + (2 << SHIFT) + (0 << (SHIFT + SHIFT)),
    (1 << 0) + (0 << SHIFT) + (2 << (SHIFT + SHIFT)),
    (1 << 0) + (2 << SHIFT) + (2 << (SHIFT + SHIFT)),
    (0 << 0) + (1 << SHIFT) + (0 << (SHIFT + SHIFT)),
    (2 << 0) + (1 << SHIFT) + (0 << (SHIFT + SHIFT)),
    (0 << 0) + (1 << SHIFT) + (2 << (SHIFT + SHIFT)),
    (2 << 0) + (1 << SHIFT) + (2 << (SHIFT + SHIFT)),
    (0 << 0) + (0 << SHIFT) + (1 << (SHIFT + SHIFT)),
    (2 << 0) + (0 << SHIFT) + (1 << (SHIFT + SHIFT)),
    (0 << 0) + (2 << SHIFT) + (1 << (SHIFT + SHIFT)),
    (2 << 0) + (2 << SHIFT) + (1 << (SHIFT + SHIFT))
};

//========================================================================================================================================================================================================================
// edge_directions lists the direction vector for all cube edges
//========================================================================================================================================================================================================================
const glm::dvec3 edge_directions[12] =
{
    glm::dvec3(1.0, 0.0, 0.0),
    glm::dvec3(1.0, 0.0, 0.0),
    glm::dvec3(1.0, 0.0, 0.0),
    glm::dvec3(1.0, 0.0, 0.0),
    glm::dvec3(0.0, 1.0, 0.0),
    glm::dvec3(0.0, 1.0, 0.0),
    glm::dvec3(0.0, 1.0, 0.0),
    glm::dvec3(0.0, 1.0, 0.0),
    glm::dvec3(0.0, 0.0, 1.0),
    glm::dvec3(0.0, 0.0, 1.0),
    glm::dvec3(0.0, 0.0, 1.0),
    glm::dvec3(0.0, 0.0, 1.0)
};

//========================================================================================================================================================================================================================
// intersected_edges[N] is a bitmask showing which edges of the cube of type N are intersected by the isosurface for each intersected edge a new vertex 
// in a vertex buffer will be generated. the position of this new vertex depends only on the value of the function on two neighbouring vertices and the 
// iso-value and calculated as if the function was linear,  hence position is the same for all cubes which share this same edge
//========================================================================================================================================================================================================================
const GLushort intersected_edges[0x100] =
{
    0x000, 0x111, 0x221, 0x330, 0x412, 0x503, 0x633, 0x722, 0x822, 0x933, 0xa03, 0xb12, 0xc30, 0xd21, 0xe11, 0xf00, 
    0x144, 0x055, 0x365, 0x274, 0x556, 0x447, 0x777, 0x666, 0x966, 0x877, 0xb47, 0xa56, 0xd74, 0xc65, 0xf55, 0xe44, 
    0x284, 0x395, 0x0a5, 0x1b4, 0x696, 0x787, 0x4b7, 0x5a6, 0xaa6, 0xbb7, 0x887, 0x996, 0xeb4, 0xfa5, 0xc95, 0xd84, 
    0x3c0, 0x2d1, 0x1e1, 0x0f0, 0x7d2, 0x6c3, 0x5f3, 0x4e2, 0xbe2, 0xaf3, 0x9c3, 0x8d2, 0xff0, 0xee1, 0xdd1, 0xcc0, 
    0x448, 0x559, 0x669, 0x778, 0x05a, 0x14b, 0x27b, 0x36a, 0xc6a, 0xd7b, 0xe4b, 0xf5a, 0x878, 0x969, 0xa59, 0xb48, 
    0x50c, 0x41d, 0x72d, 0x63c, 0x11e, 0x00f, 0x33f, 0x22e, 0xd2e, 0xc3f, 0xf0f, 0xe1e, 0x93c, 0x82d, 0xb1d, 0xa0c, 
    0x6cc, 0x7dd, 0x4ed, 0x5fc, 0x2de, 0x3cf, 0x0ff, 0x1ee, 0xeee, 0xfff, 0xccf, 0xdde, 0xafc, 0xbed, 0x8dd, 0x9cc, 
    0x788, 0x699, 0x5a9, 0x4b8, 0x39a, 0x28b, 0x1bb, 0x0aa, 0xfaa, 0xebb, 0xd8b, 0xc9a, 0xbb8, 0xaa9, 0x999, 0x888, 
    0x888, 0x999, 0xaa9, 0xbb8, 0xc9a, 0xd8b, 0xebb, 0xfaa, 0x0aa, 0x1bb, 0x28b, 0x39a, 0x4b8, 0x5a9, 0x699, 0x788, 
    0x9cc, 0x8dd, 0xbed, 0xafc, 0xdde, 0xccf, 0xfff, 0xeee, 0x1ee, 0x0ff, 0x3cf, 0x2de, 0x5fc, 0x4ed, 0x7dd, 0x6cc, 
    0xa0c, 0xb1d, 0x82d, 0x93c, 0xe1e, 0xf0f, 0xc3f, 0xd2e, 0x22e, 0x33f, 0x00f, 0x11e, 0x63c, 0x72d, 0x41d, 0x50c, 
    0xb48, 0xa59, 0x969, 0x878, 0xf5a, 0xe4b, 0xd7b, 0xc6a, 0x36a, 0x27b, 0x14b, 0x05a, 0x778, 0x669, 0x559, 0x448, 
    0xcc0, 0xdd1, 0xee1, 0xff0, 0x8d2, 0x9c3, 0xaf3, 0xbe2, 0x4e2, 0x5f3, 0x6c3, 0x7d2, 0x0f0, 0x1e1, 0x2d1, 0x3c0, 
    0xd84, 0xc95, 0xfa5, 0xeb4, 0x996, 0x887, 0xbb7, 0xaa6, 0x5a6, 0x4b7, 0x787, 0x696, 0x1b4, 0x0a5, 0x395, 0x284, 
    0xe44, 0xf55, 0xc65, 0xd74, 0xa56, 0xb47, 0x877, 0x966, 0x666, 0x777, 0x447, 0x556, 0x274, 0x365, 0x055, 0x144, 
    0xf00, 0xe11, 0xd21, 0xc30, 0xb12, 0xa03, 0x933, 0x822, 0x722, 0x633, 0x503, 0x412, 0x330, 0x221, 0x111, 0x000, 
};

//========================================================================================================================================================================================================================
// surface_triangles[N] is a list of triangles that must be generated for a cube of type N
// -1 means the end of the triangles list
//========================================================================================================================================================================================================================
const GLbyte surface_triangles[0x100][0x10] = 
{
    {-1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8, 4, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 5, 9, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 8, 4,  9, 8, 5, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 4,10, 1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0,10, 1,  8,10, 0, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 9, 0,  1, 4,10, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5,10, 1,  5, 9,10,  9, 8,10, -1,-1,-1, -1,-1,-1, -1},
    { 5, 1,11, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8, 4,  5, 1,11, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 9, 1,11,  0, 1, 9, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 1, 8, 4,  1,11, 8, 11, 9, 8, -1,-1,-1, -1,-1,-1, -1},
    { 4,11, 5, 10,11, 4, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0,11, 5,  0, 8,11,  8,10,11, -1,-1,-1, -1,-1,-1, -1},
    { 4, 9, 0,  4,10, 9, 10,11, 9, -1,-1,-1, -1,-1,-1, -1},
    { 9, 8,11, 11, 8,10, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2, 6, 8, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2, 4, 0,  6, 4, 2, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 5, 9,  8, 2, 6, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2, 5, 9,  2, 6, 5,  6, 4, 5, -1,-1,-1, -1,-1,-1, -1},
    { 8, 2, 6,  4,10, 1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    {10, 2, 6, 10, 1, 2,  1, 0, 2, -1,-1,-1, -1,-1,-1, -1},
    { 9, 0, 5,  8, 2, 6,  1, 4,10, -1,-1,-1, -1,-1,-1, -1},
    { 2, 6,10,  9, 2,10,  9,10, 1,  9, 1, 5, -1,-1,-1, -1},
    { 5, 1,11,  8, 2, 6, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 4, 2, 6,  4, 0, 2,  5, 1,11, -1,-1,-1, -1,-1,-1, -1},
    { 9, 1,11,  9, 0, 1,  8, 2, 6, -1,-1,-1, -1,-1,-1, -1},
    { 1,11, 9,  1, 9, 6,  1, 6, 4,  6, 9, 2, -1,-1,-1, -1},
    { 4,11, 5,  4,10,11,  6, 8, 2, -1,-1,-1, -1,-1,-1, -1},
    { 5,10,11,  5, 2,10,  5, 0, 2,  6,10, 2, -1,-1,-1, -1},
    { 2, 6, 8,  9, 0,10,  9,10,11, 10, 0, 4, -1,-1,-1, -1},
    { 2, 6,10,  2,10, 9,  9,10,11, -1,-1,-1, -1,-1,-1, -1},
    { 9, 7, 2, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 9, 7, 2,  0, 8, 4, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 7, 2,  5, 7, 0, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 8, 7, 2,  8, 4, 7,  4, 5, 7, -1,-1,-1, -1,-1,-1, -1},
    { 9, 7, 2,  1, 4,10, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0,10, 1,  0, 8,10,  2, 9, 7, -1,-1,-1, -1,-1,-1, -1},
    { 0, 7, 2,  0, 5, 7,  1, 4,10, -1,-1,-1, -1,-1,-1, -1},
    { 1, 5, 7,  1, 7, 8,  1, 8,10,  2, 8, 7, -1,-1,-1, -1},
    { 5, 1,11,  9, 7, 2, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 4, 0, 8,  5, 1,11,  2, 9, 7, -1,-1,-1, -1,-1,-1, -1},
    { 7, 1,11,  7, 2, 1,  2, 0, 1, -1,-1,-1, -1,-1,-1, -1},
    { 1,11, 7,  4, 1, 7,  4, 7, 2,  4, 2, 8, -1,-1,-1, -1},
    {11, 4,10, 11, 5, 4,  9, 7, 2, -1,-1,-1, -1,-1,-1, -1},
    { 2, 9, 7,  0, 8, 5,  8,11, 5,  8,10,11, -1,-1,-1, -1},
    { 7, 2, 0,  7, 0,10,  7,10,11, 10, 0, 4, -1,-1,-1, -1},
    { 7, 2, 8,  7, 8,11, 11, 8,10, -1,-1,-1, -1,-1,-1, -1},
    { 9, 6, 8,  7, 6, 9, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 9, 4, 0,  9, 7, 4,  7, 6, 4, -1,-1,-1, -1,-1,-1, -1},
    { 0, 6, 8,  0, 5, 6,  5, 7, 6, -1,-1,-1, -1,-1,-1, -1},
    { 5, 7, 4,  4, 7, 6, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 6, 9, 7,  6, 8, 9,  4,10, 1, -1,-1,-1, -1,-1,-1, -1},
    { 9, 7, 6,  9, 6, 1,  9, 1, 0,  1, 6,10, -1,-1,-1, -1},
    { 1, 4,10,  0, 5, 8,  5, 6, 8,  5, 7, 6, -1,-1,-1, -1},
    {10, 1, 5, 10, 5, 6,  6, 5, 7, -1,-1,-1, -1,-1,-1, -1},
    { 9, 6, 8,  9, 7, 6, 11, 5, 1, -1,-1,-1, -1,-1,-1, -1},
    {11, 5, 1,  9, 7, 0,  7, 4, 0,  7, 6, 4, -1,-1,-1, -1},
    { 8, 0, 1,  8, 1, 7,  8, 7, 6, 11, 7, 1, -1,-1,-1, -1},
    { 1,11, 7,  1, 7, 4,  4, 7, 6, -1,-1,-1, -1,-1,-1, -1},
    { 9, 7, 8,  8, 7, 6, 11, 5, 4, 11, 4,10, -1,-1,-1, -1},
    { 7, 6, 0,  7, 0, 9,  6,10, 0,  5, 0,11, 10,11, 0, -1},
    {10,11, 0, 10, 0, 4, 11, 7, 0,  8, 0, 6,  7, 6, 0, -1},
    {10,11, 7,  6,10, 7, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 6, 3,10, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 4, 0, 8, 10, 6, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 5, 9, 10, 6, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 8, 5, 9,  8, 4, 5, 10, 6, 3, -1,-1,-1, -1,-1,-1, -1},
    { 6, 1, 4,  3, 1, 6, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 6, 0, 8,  6, 3, 0,  3, 1, 0, -1,-1,-1, -1,-1,-1, -1},
    { 1, 6, 3,  1, 4, 6,  0, 5, 9, -1,-1,-1, -1,-1,-1, -1},
    { 5, 3, 1,  5, 8, 3,  5, 9, 8,  8, 6, 3, -1,-1,-1, -1},
    {11, 5, 1,  3,10, 6, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 1,11,  4, 0, 8,  3,10, 6, -1,-1,-1, -1,-1,-1, -1},
    { 1, 9, 0,  1,11, 9,  3,10, 6, -1,-1,-1, -1,-1,-1, -1},
    { 3,10, 6,  1,11, 4, 11, 8, 4, 11, 9, 8, -1,-1,-1, -1},
    {11, 6, 3, 11, 5, 6,  5, 4, 6, -1,-1,-1, -1,-1,-1, -1},
    {11, 6, 3,  5, 6,11,  5, 8, 6,  5, 0, 8, -1,-1,-1, -1},
    { 0, 4, 6,  0, 6,11,  0,11, 9,  3,11, 6, -1,-1,-1, -1},
    { 6, 3,11,  6,11, 8,  8,11, 9, -1,-1,-1, -1,-1,-1, -1},
    { 3, 8, 2, 10, 8, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 4, 3,10,  4, 0, 3,  0, 2, 3, -1,-1,-1, -1,-1,-1, -1},
    { 8, 3,10,  8, 2, 3,  9, 0, 5, -1,-1,-1, -1,-1,-1, -1},
    { 9, 2, 3,  9, 3, 4,  9, 4, 5, 10, 4, 3, -1,-1,-1, -1},
    { 8, 1, 4,  8, 2, 1,  2, 3, 1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 2, 1,  2, 3, 1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 9, 0,  1, 4, 2,  1, 2, 3,  2, 4, 8, -1,-1,-1, -1},
    { 5, 9, 2,  5, 2, 1,  1, 2, 3, -1,-1,-1, -1,-1,-1, -1},
    { 3, 8, 2,  3,10, 8,  1,11, 5, -1,-1,-1, -1,-1,-1, -1},
    { 5, 1,11,  4, 0,10,  0, 3,10,  0, 2, 3, -1,-1,-1, -1},
    { 2,10, 8,  2, 3,10,  0, 1, 9,  1,11, 9, -1,-1,-1, -1},
    {11, 9, 4, 11, 4, 1,  9, 2, 4, 10, 4, 3,  2, 3, 4, -1},
    { 8, 5, 4,  8, 3, 5,  8, 2, 3,  3,11, 5, -1,-1,-1, -1},
    {11, 5, 0, 11, 0, 3,  3, 0, 2, -1,-1,-1, -1,-1,-1, -1},
    { 2, 3, 4,  2, 4, 8,  3,11, 4,  0, 4, 9, 11, 9, 4, -1},
    {11, 9, 2,  3,11, 2, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2, 9, 7,  6, 3,10, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8, 4,  2, 9, 7, 10, 6, 3, -1,-1,-1, -1,-1,-1, -1},
    { 7, 0, 5,  7, 2, 0,  6, 3,10, -1,-1,-1, -1,-1,-1, -1},
    {10, 6, 3,  8, 4, 2,  4, 7, 2,  4, 5, 7, -1,-1,-1, -1},
    { 6, 1, 4,  6, 3, 1,  7, 2, 9, -1,-1,-1, -1,-1,-1, -1},
    { 9, 7, 2,  0, 8, 3,  0, 3, 1,  3, 8, 6, -1,-1,-1, -1},
    { 4, 3, 1,  4, 6, 3,  5, 7, 0,  7, 2, 0, -1,-1,-1, -1},
    { 3, 1, 8,  3, 8, 6,  1, 5, 8,  2, 8, 7,  5, 7, 8, -1},
    { 9, 7, 2, 11, 5, 1,  6, 3,10, -1,-1,-1, -1,-1,-1, -1},
    { 3,10, 6,  5, 1,11,  0, 8, 4,  2, 9, 7, -1,-1,-1, -1},
    { 6, 3,10,  7, 2,11,  2, 1,11,  2, 0, 1, -1,-1,-1, -1},
    { 4, 2, 8,  4, 7, 2,  4, 1, 7, 11, 7, 1, 10, 6, 3, -1},
    { 9, 7, 2, 11, 5, 3,  5, 6, 3,  5, 4, 6, -1,-1,-1, -1},
    { 5, 3,11,  5, 6, 3,  5, 0, 6,  8, 6, 0,  9, 7, 2, -1},
    { 2, 0,11,  2,11, 7,  0, 4,11,  3,11, 6,  4, 6,11, -1},
    { 6, 3,11,  6,11, 8,  7, 2,11,  2, 8,11, -1,-1,-1, -1},
    { 3, 9, 7,  3,10, 9, 10, 8, 9, -1,-1,-1, -1,-1,-1, -1},
    { 4, 3,10,  0, 3, 4,  0, 7, 3,  0, 9, 7, -1,-1,-1, -1},
    { 0,10, 8,  0, 7,10,  0, 5, 7,  7, 3,10, -1,-1,-1, -1},
    { 3,10, 4,  3, 4, 7,  7, 4, 5, -1,-1,-1, -1,-1,-1, -1},
    { 7, 8, 9,  7, 1, 8,  7, 3, 1,  4, 8, 1, -1,-1,-1, -1},
    { 9, 7, 3,  9, 3, 0,  0, 3, 1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 7, 8,  5, 8, 0,  7, 3, 8,  4, 8, 1,  3, 1, 8, -1},
    { 5, 7, 3,  1, 5, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 1,11,  9, 7,10,  9,10, 8, 10, 7, 3, -1,-1,-1, -1},
    { 0,10, 4,  0, 3,10,  0, 9, 3,  7, 3, 9,  5, 1,11, -1},
    {10, 8, 7, 10, 7, 3,  8, 0, 7, 11, 7, 1,  0, 1, 7, -1},
    { 3,10, 4,  3, 4, 7,  1,11, 4, 11, 7, 4, -1,-1,-1, -1},
    { 5, 4, 3,  5, 3,11,  4, 8, 3,  7, 3, 9,  8, 9, 3, -1},
    {11, 5, 0, 11, 0, 3,  9, 7, 0,  7, 3, 0, -1,-1,-1, -1},
    { 0, 4, 8,  7, 3,11, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    {11, 7, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    {11, 3, 7, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8, 4,  7,11, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 9, 0, 5,  7,11, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 8, 4,  5, 9, 8,  7,11, 3, -1,-1,-1, -1,-1,-1, -1},
    { 1, 4,10, 11, 3, 7, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    {10, 0, 8, 10, 1, 0, 11, 3, 7, -1,-1,-1, -1,-1,-1, -1},
    { 0, 5, 9,  1, 4,10,  7,11, 3, -1,-1,-1, -1,-1,-1, -1},
    { 7,11, 3,  5, 9, 1,  9,10, 1,  9, 8,10, -1,-1,-1, -1},
    { 5, 3, 7,  1, 3, 5, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 3, 7,  5, 1, 3,  4, 0, 8, -1,-1,-1, -1,-1,-1, -1},
    { 9, 3, 7,  9, 0, 3,  0, 1, 3, -1,-1,-1, -1,-1,-1, -1},
    { 7, 9, 8,  7, 8, 1,  7, 1, 3,  4, 1, 8, -1,-1,-1, -1},
    { 3, 4,10,  3, 7, 4,  7, 5, 4, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8,10,  0,10, 7,  0, 7, 5,  7,10, 3, -1,-1,-1, -1},
    { 4,10, 3,  0, 4, 3,  0, 3, 7,  0, 7, 9, -1,-1,-1, -1},
    { 3, 7, 9,  3, 9,10, 10, 9, 8, -1,-1,-1, -1,-1,-1, -1},
    { 7,11, 3,  2, 6, 8, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2, 4, 0,  2, 6, 4,  3, 7,11, -1,-1,-1, -1,-1,-1, -1},
    { 5, 9, 0,  7,11, 3,  8, 2, 6, -1,-1,-1, -1,-1,-1, -1},
    {11, 3, 7,  5, 9, 6,  5, 6, 4,  6, 9, 2, -1,-1,-1, -1},
    { 4,10, 1,  6, 8, 2, 11, 3, 7, -1,-1,-1, -1,-1,-1, -1},
    { 7,11, 3,  2, 6, 1,  2, 1, 0,  1, 6,10, -1,-1,-1, -1},
    { 0, 5, 9,  2, 6, 8,  1, 4,10,  7,11, 3, -1,-1,-1, -1},
    { 9, 1, 5,  9,10, 1,  9, 2,10,  6,10, 2,  7,11, 3, -1},
    { 3, 5, 1,  3, 7, 5,  2, 6, 8, -1,-1,-1, -1,-1,-1, -1},
    { 5, 1, 7,  7, 1, 3,  4, 0, 2,  4, 2, 6, -1,-1,-1, -1},
    { 8, 2, 6,  9, 0, 7,  0, 3, 7,  0, 1, 3, -1,-1,-1, -1},
    { 6, 4, 9,  6, 9, 2,  4, 1, 9,  7, 9, 3,  1, 3, 9, -1},
    { 8, 2, 6,  4,10, 7,  4, 7, 5,  7,10, 3, -1,-1,-1, -1},
    { 7, 5,10,  7,10, 3,  5, 0,10,  6,10, 2,  0, 2,10, -1},
    { 0, 7, 9,  0, 3, 7,  0, 4, 3, 10, 3, 4,  8, 2, 6, -1},
    { 3, 7, 9,  3, 9,10,  2, 6, 9,  6,10, 9, -1,-1,-1, -1},
    {11, 2, 9,  3, 2,11, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2,11, 3,  2, 9,11,  0, 8, 4, -1,-1,-1, -1,-1,-1, -1},
    {11, 0, 5, 11, 3, 0,  3, 2, 0, -1,-1,-1, -1,-1,-1, -1},
    { 8, 4, 5,  8, 5, 3,  8, 3, 2,  3, 5,11, -1,-1,-1, -1},
    {11, 2, 9, 11, 3, 2, 10, 1, 4, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8, 1,  1, 8,10,  2, 9,11,  2,11, 3, -1,-1,-1, -1},
    { 4,10, 1,  0, 5, 3,  0, 3, 2,  3, 5,11, -1,-1,-1, -1},
    { 3, 2, 5,  3, 5,11,  2, 8, 5,  1, 5,10,  8,10, 5, -1},
    { 5, 2, 9,  5, 1, 2,  1, 3, 2, -1,-1,-1, -1,-1,-1, -1},
    { 4, 0, 8,  5, 1, 9,  1, 2, 9,  1, 3, 2, -1,-1,-1, -1},
    { 0, 1, 2,  2, 1, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 8, 4, 1,  8, 1, 2,  2, 1, 3, -1,-1,-1, -1,-1,-1, -1},
    { 9, 3, 2,  9, 4, 3,  9, 5, 4, 10, 3, 4, -1,-1,-1, -1},
    { 8,10, 5,  8, 5, 0, 10, 3, 5,  9, 5, 2,  3, 2, 5, -1},
    { 4,10, 3,  4, 3, 0,  0, 3, 2, -1,-1,-1, -1,-1,-1, -1},
    { 3, 2, 8, 10, 3, 8, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 6,11, 3,  6, 8,11,  8, 9,11, -1,-1,-1, -1,-1,-1, -1},
    { 0, 6, 4,  0,11, 6,  0, 9,11,  3, 6,11, -1,-1,-1, -1},
    {11, 3, 6,  5,11, 6,  5, 6, 8,  5, 8, 0, -1,-1,-1, -1},
    {11, 3, 6, 11, 6, 5,  5, 6, 4, -1,-1,-1, -1,-1,-1, -1},
    { 1, 4,10, 11, 3, 8, 11, 8, 9,  8, 3, 6, -1,-1,-1, -1},
    { 1, 0, 6,  1, 6,10,  0, 9, 6,  3, 6,11,  9,11, 6, -1},
    { 5, 8, 0,  5, 6, 8,  5,11, 6,  3, 6,11,  1, 4,10, -1},
    {10, 1, 5, 10, 5, 6, 11, 3, 5,  3, 6, 5, -1,-1,-1, -1},
    { 5, 1, 3,  5, 3, 8,  5, 8, 9,  8, 3, 6, -1,-1,-1, -1},
    { 1, 3, 9,  1, 9, 5,  3, 6, 9,  0, 9, 4,  6, 4, 9, -1},
    { 6, 8, 0,  6, 0, 3,  3, 0, 1, -1,-1,-1, -1,-1,-1, -1},
    { 6, 4, 1,  3, 6, 1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 8, 9, 3,  8, 3, 6,  9, 5, 3, 10, 3, 4,  5, 4, 3, -1},
    { 0, 9, 5, 10, 3, 6, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 6, 8, 0,  6, 0, 3,  4,10, 0, 10, 3, 0, -1,-1,-1, -1},
    { 6,10, 3, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    {10, 7,11,  6, 7,10, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    {10, 7,11, 10, 6, 7,  8, 4, 0, -1,-1,-1, -1,-1,-1, -1},
    { 7,10, 6,  7,11,10,  5, 9, 0, -1,-1,-1, -1,-1,-1, -1},
    {11, 6, 7, 11,10, 6,  9, 8, 5,  8, 4, 5, -1,-1,-1, -1},
    { 1, 7,11,  1, 4, 7,  4, 6, 7, -1,-1,-1, -1,-1,-1, -1},
    { 8, 1, 0,  8, 7, 1,  8, 6, 7, 11, 1, 7, -1,-1,-1, -1},
    { 9, 0, 5,  7,11, 4,  7, 4, 6,  4,11, 1, -1,-1,-1, -1},
    { 9, 8, 1,  9, 1, 5,  8, 6, 1, 11, 1, 7,  6, 7, 1, -1},
    {10, 5, 1, 10, 6, 5,  6, 7, 5, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8, 4,  5, 1, 6,  5, 6, 7,  6, 1,10, -1,-1,-1, -1},
    { 9, 6, 7,  9, 1, 6,  9, 0, 1,  1,10, 6, -1,-1,-1, -1},
    { 6, 7, 1,  6, 1,10,  7, 9, 1,  4, 1, 8,  9, 8, 1, -1},
    { 5, 4, 7,  4, 6, 7, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8, 6,  0, 6, 5,  5, 6, 7, -1,-1,-1, -1,-1,-1, -1},
    { 9, 0, 4,  9, 4, 7,  7, 4, 6, -1,-1,-1, -1,-1,-1, -1},
    { 9, 8, 6,  7, 9, 6, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 7, 8, 2,  7,11, 8, 11,10, 8, -1,-1,-1, -1,-1,-1, -1},
    { 7, 0, 2,  7,10, 0,  7,11,10, 10, 4, 0, -1,-1,-1, -1},
    { 0, 5, 9,  8, 2,11,  8,11,10, 11, 2, 7, -1,-1,-1, -1},
    {11,10, 2, 11, 2, 7, 10, 4, 2,  9, 2, 5,  4, 5, 2, -1},
    { 1, 7,11,  4, 7, 1,  4, 2, 7,  4, 8, 2, -1,-1,-1, -1},
    { 7,11, 1,  7, 1, 2,  2, 1, 0, -1,-1,-1, -1,-1,-1, -1},
    { 4,11, 1,  4, 7,11,  4, 8, 7,  2, 7, 8,  0, 5, 9, -1},
    { 7,11, 1,  7, 1, 2,  5, 9, 1,  9, 2, 1, -1,-1,-1, -1},
    { 1, 7, 5,  1, 8, 7,  1,10, 8,  2, 7, 8, -1,-1,-1, -1},
    { 0, 2,10,  0,10, 4,  2, 7,10,  1,10, 5,  7, 5,10, -1},
    { 0, 1, 7,  0, 7, 9,  1,10, 7,  2, 7, 8, 10, 8, 7, -1},
    { 9, 2, 7,  1,10, 4, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 8, 2, 7,  8, 7, 4,  4, 7, 5, -1,-1,-1, -1,-1,-1, -1},
    { 0, 2, 7,  5, 0, 7, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 8, 2, 7,  8, 7, 4,  9, 0, 7,  0, 4, 7, -1,-1,-1, -1},
    { 9, 2, 7, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2,10, 6,  2, 9,10,  9,11,10, -1,-1,-1, -1,-1,-1, -1},
    { 0, 8, 4,  2, 9, 6,  9,10, 6,  9,11,10, -1,-1,-1, -1},
    { 5,11,10,  5,10, 2,  5, 2, 0,  6, 2,10, -1,-1,-1, -1},
    { 4, 5, 2,  4, 2, 8,  5,11, 2,  6, 2,10, 11,10, 2, -1},
    { 1, 9,11,  1, 6, 9,  1, 4, 6,  6, 2, 9, -1,-1,-1, -1},
    { 9,11, 6,  9, 6, 2, 11, 1, 6,  8, 6, 0,  1, 0, 6, -1},
    { 4, 6,11,  4,11, 1,  6, 2,11,  5,11, 0,  2, 0,11, -1},
    { 5,11, 1,  8, 6, 2, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2,10, 6,  9,10, 2,  9, 1,10,  9, 5, 1, -1,-1,-1, -1},
    { 9, 6, 2,  9,10, 6,  9, 5,10,  1,10, 5,  0, 8, 4, -1},
    {10, 6, 2, 10, 2, 1,  1, 2, 0, -1,-1,-1, -1,-1,-1, -1},
    {10, 6, 2, 10, 2, 1,  8, 4, 2,  4, 1, 2, -1,-1,-1, -1},
    { 2, 9, 5,  2, 5, 6,  6, 5, 4, -1,-1,-1, -1,-1,-1, -1},
    { 2, 9, 5,  2, 5, 6,  0, 8, 5,  8, 6, 5, -1,-1,-1, -1},
    { 2, 0, 4,  6, 2, 4, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 2, 8, 6, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 9,11, 8, 11,10, 8, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 4, 0, 9,  4, 9,10, 10, 9,11, -1,-1,-1, -1,-1,-1, -1},
    { 0, 5,11,  0,11, 8,  8,11,10, -1,-1,-1, -1,-1,-1, -1},
    { 4, 5,11, 10, 4,11, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 1, 4, 8,  1, 8,11, 11, 8, 9, -1,-1,-1, -1,-1,-1, -1},
    { 9,11, 1,  0, 9, 1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 1, 4, 8,  1, 8,11,  0, 5, 8,  5,11, 8, -1,-1,-1, -1},
    { 5,11, 1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 1,10,  5,10, 9,  9,10, 8, -1,-1,-1, -1,-1,-1, -1},
    { 4, 0, 9,  4, 9,10,  5, 1, 9,  1,10, 9, -1,-1,-1, -1},
    { 0, 1,10,  8, 0,10, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 4, 1,10, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 5, 4, 8,  9, 5, 8, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 9, 5, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    { 0, 4, 8, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1},
    {-1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1,-1,-1, -1}
}; 

//========================================================================================================================================================================================================================
// tetrahedral gradient
//========================================================================================================================================================================================================================
glm::dvec3 gradient(scalar_field func, const glm::dvec3& point, const double gradient_delta)
{
    double f100 = func(point + glm::dvec3( gradient_delta, -gradient_delta, -gradient_delta));
    double f001 = func(point + glm::dvec3(-gradient_delta, -gradient_delta,  gradient_delta));
    double f010 = func(point + glm::dvec3(-gradient_delta,  gradient_delta, -gradient_delta));  
    double f111 = func(point + glm::dvec3( gradient_delta,  gradient_delta,  gradient_delta));

    return glm::normalize(glm::dvec3( f100 - f001 - f010 + f111, 
                                     -f100 - f001 + f010 + f111, 
                                     -f100 + f001 - f010 + f111));
}

//========================================================================================================================================================================================================================
// common constants
//========================================================================================================================================================================================================================
const int CUBE_SIZE = 256;
const int CUBE_SIZE_PLUS_1 = CUBE_SIZE + 1;

const double CUBE_MIN_BOUND = -1.0;
const double CUBE_MAX_BOUND =  1.0;
const double DELTA = (CUBE_MAX_BOUND - CUBE_MIN_BOUND) / double(CUBE_SIZE);
const double GRADIENT_DELTA = 0.0625 * DELTA;

//========================================================================================================================================================================================================================
// constructs indexed mesh, representing field level surface
// original, non-optimized implementation taken from :: http://paulbourke.net/geometry/polygonise/
// vertex and edge enumeration was modified to be more convenient to use in the optimized routine 
// intersected_edges bitmasks and surface_triangles lists were also adjusted accordingly
// quite non-optimal as it evaluates field value at every lattice point about 8 times
//========================================================================================================================================================================================================================
void iso_surface_t::generate_vao_ori(scalar_field func)
{
    //====================================================================================================================================================================================================================
    // data arrays to be used as attribute and index buffers
    //====================================================================================================================================================================================================================
    std::vector<vertex_pn_t> vertices;
    std::vector<GLuint> indices;

    std::map<GLuint, GLuint> edge_to_index;

    GLuint vertex_index = 0;

    glm::dvec3 base_point;
    base_point.z = CUBE_MIN_BOUND;

    double values[8];

    for (GLuint r = 0; r < CUBE_SIZE; ++r)
    {
        base_point.y = CUBE_MIN_BOUND;
        for (GLuint q = 0; q < CUBE_SIZE; ++q)
        {
            base_point.x = CUBE_MIN_BOUND;
            for (GLuint p = 0; p < CUBE_SIZE; ++p)
            {
                //========================================================================================================================================================================================================
                // calculate function values at the cube's corners and the cube type, 
                // i.e compute mask which vertices are inside of the isosurface (the value at the vertex is below the isovalue) and which are outside of it
                //========================================================================================================================================================================================================

                GLuint cube_type = 0;
                GLuint mask = 1;
                
                for (GLuint i = 0; i < 8; ++i)
                {
                    values[i] = func(base_point + DELTA * cube_vertices[i]);
                    if (values[i] < 0.0) cube_type |= mask;
                    mask <<= 1;
                }

                //========================================================================================================================================================================================================
                // find which edges are intersected by the surface
                // nothing to do if the cube is entirely inside or outside of the surface
                //========================================================================================================================================================================================================
                GLuint edges_bitmask = intersected_edges[cube_type];

                if (!edges_bitmask)
                { 
                    base_point.x += DELTA;
                    continue;
                }
                
                //========================================================================================================================================================================================================
                // Find the point of intersection of the surface with each edge, then find the normal to the surface at those points
                //========================================================================================================================================================================================================
                mask = 1;
                GLuint edge_global_hash = (p << 1) + (q << (SHIFT + 1)) + (r << (SHIFT + SHIFT + 1));
                GLuint buffer_index[12];

                for(GLuint i = 0; i < 12; i++)
                {
                    //====================================================================================================================================================================================================
                    // if there is an intersection on this edge
                    //====================================================================================================================================================================================================
                    if(edges_bitmask & mask)
                    {
                        GLuint edge_hash = edge_global_hash + edge_local_hash[i];                       
                        std::map<GLuint, GLuint>::iterator it = edge_to_index.find(edge_hash);

                        //================================================================================================================================================================================================
                        // if the vertex already exists, get its index, otherwise create a new one
                        //================================================================================================================================================================================================
                        if (it != edge_to_index.end())
                            buffer_index[i] = it->second;                                       
                        else
                        {
                            //============================================================================================================================================================================================
                            // a new vertex has to be created
                            //============================================================================================================================================================================================
                            buffer_index[i] = vertex_index;

                            double value0 = values[cube_edges[i][0]];
                            double value1 = values[cube_edges[i][1]];
                            double offset = value0 / (value0 - value1);

                            glm::dvec3 position = base_point + DELTA * (cube_vertices[cube_edges[i][0]] + offset * edge_directions[i]);
                            glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                            vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));

                            //============================================================================================================================================================================================
                            // store index value into the map 
                            //============================================================================================================================================================================================
                            edge_to_index[edge_hash] = vertex_index;
                            vertex_index++;
                        }
                    }
                    mask <<= 1;
                }
                
                //========================================================================================================================================================================================================
                // add index triple for each triangle in the surface_triangles list for the given cube_type to the index buffer
                //========================================================================================================================================================================================================
                for (GLuint i = 0; surface_triangles[cube_type][i] != -1; i += 3)
                {
                    indices.push_back(buffer_index[surface_triangles[cube_type][i + 0]]); 
                    indices.push_back(buffer_index[surface_triangles[cube_type][i + 1]]); 
                    indices.push_back(buffer_index[surface_triangles[cube_type][i + 2]]);
                }
                
                base_point.x += DELTA;
            }           
            base_point.y += DELTA;
        }
        base_point.z += DELTA;
    }

    vao.init(GL_TRIANGLES, vertices, indices);
}

//========================================================================================================================================================================================================================
// optimized version of the same algorithm
// evaluates every field value just once, constructs surface vertices on edges on the go
// about 5 - 6 times faster than the original version
// does not use intersected edges bitmasks, uses surface_triangles list
//========================================================================================================================================================================================================================
void iso_surface_t::generate_vao(scalar_field func)
{
    //====================================================================================================================================================================================================================
    // data arrays to be used as attribute and index buffers
    //====================================================================================================================================================================================================================
    GLuint vindex = 0;
    std::vector<vertex_pn_t> vertices;
    std::vector<GLuint> indices;

    //====================================================================================================================================================================================================================
    // auxiliary data arrays
    //====================================================================================================================================================================================================================
    double z_values[CUBE_SIZE_PLUS_1 * CUBE_SIZE_PLUS_1];
    uint8_t z_masks[CUBE_SIZE * CUBE_SIZE];
    uint8_t y_masks[CUBE_SIZE];

    GLuint x_edges_0_i[CUBE_SIZE_PLUS_1][CUBE_SIZE];
    GLuint x_edges_1_i[CUBE_SIZE_PLUS_1][CUBE_SIZE];
    GLuint y_edges_0_i[CUBE_SIZE_PLUS_1][CUBE_SIZE];
    GLuint y_edges_1_i[CUBE_SIZE_PLUS_1][CUBE_SIZE];
    GLuint z_edges[CUBE_SIZE_PLUS_1][CUBE_SIZE_PLUS_1];

    GLuint (*x_edges_0)[CUBE_SIZE] = x_edges_0_i;
    GLuint (*x_edges_1)[CUBE_SIZE] = x_edges_1_i;
    GLuint (*y_edges_0)[CUBE_SIZE] = y_edges_0_i;
    GLuint (*y_edges_1)[CUBE_SIZE] = y_edges_1_i;

    double value, x_value, y_value, z_value, alpha;
    uint8_t mask, x_mask, y_mask, z_mask;
    double* value_ptr = z_values;
    uint8_t* mask_ptr = z_masks;

    //====================================================================================================================================================================================================================
    // step 0 :: compute field value in the bottom-left-back corner
    //====================================================================================================================================================================================================================
    glm::dvec3 p = glm::dvec3(CUBE_MIN_BOUND);
    value = func(p);
    mask = value < 0.0;
    *(value_ptr++) = value;

    //====================================================================================================================================================================================================================
    // step 1 :: compute field values in the (y,z) = (0,0) - row, constructing X-edges if necessary
    //====================================================================================================================================================================================================================
    for (GLuint x = 0; x < CUBE_SIZE; ++x)
    {
        x_value = value;
        x_mask = mask;
        p.x += DELTA;
        value = func(p);
        mask = value < 0.0;

        if (mask != x_mask)
        {
            alpha = value / (value - x_value);
            glm::dvec3 position = glm::dvec3(p.x - alpha * DELTA, p.y, p.z);
            glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
            vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
            x_edges_0[0][x] = vindex++;
        }

        *(value_ptr++) = value;
        y_masks[x] = x_mask | (mask << 1);
    }

    //====================================================================================================================================================================================================================
    // step 2 :: compute field values in the z = 0, y > 0 - plane
    //====================================================================================================================================================================================================================
    for(GLuint y = 0; y < CUBE_SIZE; ++y)
    {
        //================================================================================================================================================================================================================
        // step 2.1 :: compute field value in the z = 0, y - fixed, x = 0, constructing Y-edge if necessary 
        //================================================================================================================================================================================================================
        p.y += DELTA;
        p.x = CUBE_MIN_BOUND;
        value = func(p);
        mask = value < 0.0;
        y_mask = y_masks[0] & 1;

        if (y_mask != mask)
        {
            y_value = *(value_ptr - CUBE_SIZE);
            alpha = value / (value - y_value);
            glm::dvec3 position = glm::dvec3(p.x, p.y - alpha * DELTA, p.z);
            glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
            vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
            y_edges_0[0][y] = vindex++;
        }

        *(value_ptr++) = value;

        //================================================================================================================================================================================================================
        // step 2.2 :: compute the rest of the field values in the row z = 0, y - fixed, constructing both X- and Y-edges if necessary 
        //================================================================================================================================================================================================================
        for(GLuint x = 0; x < CUBE_SIZE; ++x)
        {
            x_value = value;
            x_mask = mask;
            p.x += DELTA;
            value = func(p);
            mask = value < 0.0;
            y_mask = y_masks[x];

            if (x_mask != mask)
            {
                alpha = value / (value - x_value);
                glm::dvec3 position = glm::dvec3(p.x - alpha * DELTA, p.y, p.z);
                glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                x_edges_0[y + 1][x] = vindex++;
            }

            if ((y_mask >> 1) != mask)
            {
                y_value = *(value_ptr - CUBE_SIZE_PLUS_1);
                alpha = value / (value - y_value);
                glm::dvec3 position = glm::dvec3(p.x, p.y - alpha * DELTA, p.z);
                glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                y_edges_0[x + 1][y] = vindex++; 
            }

            *(value_ptr++) = value;
            uint8_t y1_mask = x_mask | (mask << 1);
            y_masks[x] = y1_mask;
            *(mask_ptr++) = y_mask | (y1_mask << 2);
        }
    }

    //====================================================================================================================================================================================================================
    // step 3 :: the main loop in z
    //====================================================================================================================================================================================================================
    for(GLuint z = 0; z < CUBE_SIZE; ++z)
    {
        value_ptr = z_values;
        mask_ptr = z_masks;
        //================================================================================================================================================================================================================
        // working on the z-layer number z + 1 and the previous one, i.e. z
        // step 3.1 :: begin with x = 0, y = 0 point, constructing vertical z-edge if necessary
        //================================================================================================================================================================================================================
        p.x = CUBE_MIN_BOUND;
        p.y = CUBE_MIN_BOUND;
        p.z += DELTA;
        value = func(p);
        mask = value < 0.0;
        z_mask = (*mask_ptr) & 1;

        if (z_mask != mask)
        {
            z_value = *(value_ptr);
            alpha = value / (value - z_value);
            glm::dvec3 position = glm::dvec3(p.x, p.y, p.z - alpha * DELTA);
            glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
            vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
            z_edges[0][0] = vindex++;
        }

        *(value_ptr++) = value;

        //================================================================================================================================================================================================================
        // step 3.2 :: complete the first row, constructing both X- and Z- edges where needed
        //================================================================================================================================================================================================================
        for (GLuint x = 0; x < CUBE_SIZE; ++x)
        {
            x_value = value;
            x_mask = mask;
            p.x += DELTA;
            value = func(p);
            mask = value < 0.0;
            z_mask = ((*(mask_ptr++)) >> 1) & 1;

            if (mask != x_mask)
            {
                alpha = value / (value - x_value);
                glm::dvec3 position = glm::dvec3(p.x - alpha * DELTA, p.y, p.z);
                glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                x_edges_1[0][x] = vindex++;
            }

            if (mask != z_mask)
            {
                z_value = *value_ptr;
                alpha = value / (value - z_value);
                glm::dvec3 position = glm::dvec3(p.x, p.y, p.z - alpha * DELTA);
                glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                z_edges[0][x + 1] = vindex++;
            }

            *(value_ptr++) = value;
            y_masks[x] = x_mask | (mask << 1);
        }

        mask_ptr = z_masks;

        //================================================================================================================================================================================================================
        // step 3.3 :: loop in Y, completing the rest of rows
        //================================================================================================================================================================================================================
        for(GLuint y = 0; y < CUBE_SIZE; ++y)
        {
            //============================================================================================================================================================================================================
            // step 3.3.1 :: again, for the first point in a row Y- and Z- edges only can be formed
            //============================================================================================================================================================================================================
            p.y += DELTA;
            p.x = CUBE_MIN_BOUND;
            value = func(p);
            mask = value < 0.0;
            y_mask = y_masks[0] & 1;
            z_mask = ((*mask_ptr) >> 2) & 1;

            if (y_mask != mask)
            {
                y_value = *(value_ptr - CUBE_SIZE_PLUS_1);
                alpha = value / (value - y_value);
                glm::dvec3 position = glm::dvec3(p.x, p.y - alpha * DELTA, p.z);
                glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                y_edges_1[0][y] = vindex++;
            }

            if (z_mask != mask)
            {
                z_value = *(value_ptr);
                alpha = value / (value - z_value);
                glm::dvec3 position = glm::dvec3(p.x, p.y, p.z - alpha * DELTA);
                glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                z_edges[y + 1][0] = vindex++;
            }

            *(value_ptr++) = value;

            //============================================================================================================================================================================================================
            // step 3.3.2 :: generic case, where all X-, Y- and Z- edges may appear
            //============================================================================================================================================================================================================
            for(GLuint x = 0; x < CUBE_SIZE; ++x)
            {
                x_value = value;
                x_mask = mask;
                p.x += DELTA;
                value = func(p);
                mask = value < 0.0;

                y_mask = y_masks[x];
                z_mask = *mask_ptr;

                if (x_mask != mask)
                {
                    alpha = value / (value - x_value);
                    glm::dvec3 position = glm::dvec3(p.x - alpha * DELTA, p.y, p.z);
                    glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                    vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                    x_edges_1[y + 1][x] = vindex++;
                }

                if ((y_mask >> 1) != mask)
                {
                    y_value = *(value_ptr - CUBE_SIZE_PLUS_1);
                    alpha = value / (value - y_value);
                    glm::dvec3 position = glm::dvec3(p.x, p.y - alpha * DELTA, p.z);
                    glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                    vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                    y_edges_1[x + 1][y] = vindex++; 
                }

                if (((z_mask >> 3) & 1) != mask)
                {
                    z_value = *(value_ptr);
                    alpha = value / (value - z_value);
                    glm::dvec3 position = glm::dvec3(p.x, p.y, p.z - alpha * DELTA);
                    glm::dvec3 normal = gradient(func, position, GRADIENT_DELTA);
                    vertices.push_back(vertex_pn_t(glm::vec3(position), glm::vec3(normal)));
                    z_edges[y + 1][x + 1] = vindex++; 
                }

                *(value_ptr++) = value;
                uint8_t y1_mask = x_mask | (mask << 1);
                y_masks[x] = y1_mask;
                uint8_t z1_mask = (y1_mask << 2) | y_mask; 
                uint8_t cube_type = (z1_mask << 4) | z_mask;
                *(mask_ptr++) = z1_mask;

                //========================================================================================================================================================================================================
                // cell bitmask is completely computed, generate triangles
                //========================================================================================================================================================================================================
                for (GLuint i = 0; surface_triangles[cube_type][i] != -1; ++i)
                {
                    GLuint edge = surface_triangles[cube_type][i];
                    GLuint index = (edge < 0x4) ? ((edge < 0x2) ? x_edges_0[y + edge - 0x0][x] : x_edges_1[y + edge - 0x2][x]) :
                                   (edge < 0x8) ? ((edge < 0x6) ? y_edges_0[x + edge - 0x4][y] : y_edges_1[x + edge - 0x6][y]) :
                                                  ((edge < 0xA) ? z_edges[y][x + edge - 0x8] : z_edges[y + 1][x + edge - 0xA]);
                    indices.push_back(index);
                }
            }
        }

        //================================================================================================================================================================================================================
        // step 3.4 :: swap pointers to the X- and Y- edge array, so that the constructed edges will be used on the next Z - iteration
        //================================================================================================================================================================================================================
        GLuint (*x_edges)[CUBE_SIZE] = x_edges_0;
        x_edges_0 = x_edges_1;
        x_edges_1 = x_edges;
        GLuint (*y_edges)[CUBE_SIZE] = y_edges_0;
        y_edges_0 = y_edges_1;
        y_edges_1 = y_edges;

    }

    //====================================================================================================================================================================================================================
    // step 4 :: done, construct the vertex array object and index buffer from data
    //====================================================================================================================================================================================================================
    vao.init(GL_TRIANGLES, vertices, indices);    
}