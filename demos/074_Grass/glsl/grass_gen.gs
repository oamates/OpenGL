#version 330 core

layout (points) in;
layout (triangle_strip, max_vertices = 17) out; 
 
uniform mat4 projection_view_matrix;
uniform float grid_scale;

in flat ivec2 grid_point[];

out vec3 position;
out vec3 normal;
out vec2 uv;

//==============================================================================================================================================================
// hashing functions
//==============================================================================================================================================================

const vec3 hash_x[3] = vec3[3]
(
    vec3( 17.193f,  12.439f,  21.741f),
    vec3(-27.881f, -11.127f,  93.237f),
    vec3( 16.649f, -74.671f, -10.351f)
);

const vec3 hash_y[3] = vec3[3]
(
    vec3(-71.219f,  74.511f,  17.491f),
    vec3( 13.829f, -77.467f, -27.913f),
    vec3(-51.293f, -18.341f, -13.957f)
);

vec3 hash_0(ivec2 p)
{
    vec3 h = p.x * hash_x[0] + p.y * hash_y[0] + hash_x[1];
    return fract(cos(h) * 43134.717f);
}

vec3 hash_1(ivec2 p)
{
    vec3 h = p.x * hash_x[1] + p.y * hash_y[1] + hash_x[2];
    return fract(cos(h) * 43134.717f);
}

vec3 hash_2(ivec2 p)
{
    vec3 h = p.x * hash_x[2] + p.y * hash_y[2] + hash_x[0];
    return fract(cos(h) * 43134.717f);
}

//==============================================================================================================================================================
// canyon distance function
//==============================================================================================================================================================
vec3 tri(in vec3 x)
{
    vec3 q = abs(fract(x) - 0.5f);
    return q;
}

float sdf(vec3 p)
{    
    vec3 op = tri(1.1f * p + tri(1.1f * p.zxy));
    float ground = p.z + dot(op, vec3(0.067));
    p += (op - 0.25) * 0.3;
    p = cos(0.444f * p + sin(1.112f * p.zxy));
    float canyon = (length(p) - 1.05) * 0.95;
    return min(ground, canyon);
}

float canyon_sdf(vec3 p)
{
    vec3 op = tri(1.1f * p + tri(1.1f * p.zxy));
    p += (op - 0.25) * 0.3;
    p = cos(0.444f * p + sin(1.112f * p.zxy));
    return length(p) - 1.05;
}

float ground_sdf(vec3 p)
{    
    vec3 op = tri(1.1f * p + tri(1.1f * p.zxy));
    float ground = p.z + dot(op, vec3(0.067));
    return ground;
}

//==============================================================================================================================================================
// distance function gradient :: tetrahedral evaluation
//==============================================================================================================================================================
vec3 calc_normal(in vec3 p)
{
    vec2 e = vec2(0.0125, -0.0125);
    return normalize(e.xyy * sdf(p + e.xyy) + e.yyx * sdf(p + e.yyx) + e.yxy * sdf(p + e.yxy) + e.xxx * sdf(p + e.xxx));
}

//==============================================================================================================================================================
// 2-dimensional value noise for grass density function
//==============================================================================================================================================================
vec2 hermite5(vec2 x)
{
    return x * x * x * (10.0 + x * (6.0 * x - 15.0));
}

float vnoise(vec2 P) 
{
    const float FACTOR_X = 127;
    const float FACTOR_Y = 311;
    const vec4 hash = vec4(0, FACTOR_X, FACTOR_Y, FACTOR_X + FACTOR_Y);

    vec2 Pi = floor(P);
    vec2 Pf = P - Pi;

    vec4 h = dot(Pi, hash.yz) + hash;
    vec2 Ps = hermite5(Pf);
    h = fract(cos(h) * 43758.5453123);

    vec2 val = mix(h.xy, h.zw, Ps.y);
    return mix(val.x, val.y, Ps.x);
}

float density(vec2 p)
{
    vec2 q = 0.5 * p;
    float v = vnoise(q) + 0.5 * vnoise(2.11 * q) + 0.25 * vnoise(4.17 * q);
    return 0.507 * v;
}

//==============================================================================================================================================================
// shader entry point
//==============================================================================================================================================================
void main()
{
    ivec2 id = grid_point[0];

    vec3 hash = hash_0(id);


    vec2 ray = 0.0625 * (hash.xy - vec2(0.5));
    vec2 base = grid_scale * vec2(id) + ray;

    //==========================================================================================================================================================
    // check if the grass density at the basepoint is large enough
    //==========================================================================================================================================================
    float d = density(base);
    if (d < 0.6 - 0.25 * hash.z)
        return;

    vec3 p = vec3(base, 0.0);

    for(int i = 0; i < 4; ++i)
    {
        float t = ground_sdf(p);
        p.z -= t;
    }

    //==========================================================================================================================================================
    // then check that the space is not occupied by the rocks
    //==========================================================================================================================================================
    if (canyon_sdf(p) < -0.0125) 
        return;

    //==========================================================================================================================================================
    // frenet frame :: tangent + normal + binormal
    //==========================================================================================================================================================
    vec3 b = hash_1(id) - vec3(0.5);
    vec3 t = calc_normal(p);
    t = normalize(t + 0.25f * b);
    t.z = abs(t.z);
    b = normalize(b - dot(b, t) * t);
    vec3 n = cross(b, t);

    hash = hash_2(id);


    //==========================================================================================================================================================
    // gravity lean
    //==========================================================================================================================================================
    float gravity_lean = 0.445 * hash.x;  

    //==========================================================================================================================================================
    // blade angular twist
    //==========================================================================================================================================================
    float angular_twist = 0.245 * hash.y;

    //==========================================================================================================================================================
    // initial blade width
    //==========================================================================================================================================================
    float s = clamp(pow(d + 0.317, 1.8), 0.0, 1.0);
    float w = 0.01075 * hash.z * s;  
    float scale = 0.0575 * (0.2 + 0.8 * hash.z) * s;

    float x0 = (hash.x < 0.18) ? 0.0 :
               (hash.x < 0.41) ? (1.0 / 3.0) : (2.0 / 3.0);
    float x1 = x0 + 1.0 / 3.0;
    float y = 0.0;


    for (int i = 0; i < 8; ++i)
    {
        position = p - w * b;
        normal = n;
        uv = vec2(x0, y);
        gl_Position = projection_view_matrix * vec4(position, 1.0f);
        EmitVertex();

        position = p + w * b;
        normal = n;
        uv = vec2(x1, y);
        gl_Position = projection_view_matrix * vec4(position, 1.0f);
        EmitVertex();

        //======================================================================================================================================================
        // Frenet formulae :: k = curvature, t = torsion :: k ~ gravity_lean, t ~ angular_twist
        // dt / ds = kN
        // dN / ds = -kT + tB
        // dB / ds = -tN
        //======================================================================================================================================================
        w = 0.861 * w;
        p += scale * t;
        t = t + gravity_lean * n;
        b = b - angular_twist * n;
        y += 0.117;

        //======================================================================================================================================================
        // orthonormalize    
        //======================================================================================================================================================
        t = normalize(t);
        b = normalize(b - dot(t, b) * t);
        n = cross(t, b);
    }

    position = p;
    normal = n;
    uv = vec2(0.5 * (x0 + x1), y);
    gl_Position = projection_view_matrix * vec4(position, 1.0f);
    EmitVertex();

    EndPrimitive();       
}